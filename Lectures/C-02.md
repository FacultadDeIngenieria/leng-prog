---
marp: true
html: true
paginate: true
---

# C Part 2

---

## Arrays, pointers and pointer arithmetic

Arrays in C are essentially a pointer to the first element of the array.
When you increment a pointer it increments it by the size of the pointer type

```c
int a[5] = {10, 20, 30, 40};

int* ptr = a; // Pointer to the first element of a
* (ptr + 1) = 22;
printf("a = {%d, %d, %d, %d}\n", a[0], a[1], a[2], a[3]);

ptr += 2;     // Now points to the third element of a
*ptr += 14;
printf("a = {%d, %d, %d, %d}\n", a[0], a[1], a[2], a[3]);
```
Output
```bash
a = {10, 22, 30, 40}
a = {10, 22, 44, 40}
```
---
## Structures in C

Like the fields of a `class` in Java.

Define a structure

```c
struct Person {
    char name[50];
    int age;
    float height;
};
```
Define a variable with the type of the structure and fill it
```c
struct Person john;
strcpy(john.name, "John Doe");  // Copying a string into the name field
john.age = 30;                  // Setting the age
john.height = 170;              // Setting the height
```
---
## Where is the memory allocated?

```c

// static: lives for the whole duration of the program execution
struct Person person1 = { "Jack", 18, 180 }; // static

void f() {
    // stack: lives while `f` is alive
    struct Person person2 = { "John", 21, 170 };
    printf("%s\n", person1.name);
    printf("%s\n", person2.name);
}
```

---

## Memory Allocation in C
- C allows you to handle memory allocation manually
- `malloc` is used to allocate memory
- `free` are used to free it.
- The memory is allocated in the 'heap'
- You are responsible of returning the memory to the heap (Using `free`)

---
## Example:

```c
// Create an array of `n` elements
// fill them with the given value
int* createArray(int n, int value) {
    // Allocates space for n integers
    int* array = (int*) malloc(n * sizeof(int));
    for (int i = 0; i< n; i++) 
        array[i] = value;
    return array;     
}
// Use it
int main() {
	int* a = createArray(3, 100);
	for (int i = 0; i < 3; i++) printf("a[%d] = %d\n", i, a[i]);
	free(a);
}
```
Output
```bash
a[0] = 100
a[1] = 100
a[2] = 100
```
---

## Problems with Memory Handling in C

- Memory leaks occur if `free` is not called after `malloc`.
- If you try to free an already freed block of memory you can get a crash
- Dangling pointers
  - It is a pointer to an already freed block of memory.
  - Using it can cause errors difficult to detect
  - Like modifying the memory of a different object
---

## Implementing a Stack in C

The node:
```c
struct Node {
    int value;
    struct Node* next;
};
```
Then I need a pointer to the first Node, (or to NULL if the stack is empty).

The functions that manipulate the stack (`pop`, `push`, etc) need to modify that pointer,
to be able to do that I will need to pass a pointer to the pointer of the first node.
To simplify the interface, I define a `typedef` alias:

```c
typedef struct Node** Stack;
```

---

## Using the stack
```c
Stack s = create_stack();   // Create the stack

push(s, 10);                // Push 2 values
push(s, 20);

printf("%d\n", pop(s));    // Pop the Values
printf("%d\n", pop(s));

delete_stack(s);           // Delete the stack
```
Output
```bash
20
10
```
---

## Push

- Allocate memory for a new node
- Fill the node with:
  - The value
  - The previous top of the `Stack`
  - Modify the top of the `Stack`

```c
void push(Stack stack, int value) {
    struct Node* node = (struct Node *) malloc(sizeof(struct Node));
    node->value = value;
    node->next = *stack;
    *stack = node;
}
```

---

## Pop

- Get current top and value
- Modify the top of the `Stack` (point it to the next `Node`)
- Free the memory of the previous top `Node`

```c
vint pop(Stack stack) {
    struct Node* node = *stack;
    int value = node->value;
    *stack = node->next;
    free(node);
    return value;
}

```

---

### Create a new `Stack`

- Allocate memory to hold the pointer to the top `Node`
- Fill it with `NULL`
- return it

```c
Stack create_stack() {
    Stack s = (struct Node**) malloc(sizeof(struct Node*));
    *s = NULL;
    return s;
}
```

---

### Delete the `Stack` (free associated memory)

- Get the pointer to the first `Node`
- While the pointer is not `NULL`
- Advance the pointer and free each `Node`
- Finally free the pointer to the first `Node`

```c
void delete_stack(Stack stack) {
    struct Node* node = *stack;
    while (node != NULL) {
        struct Node* current = node;
        node = node->next;
        free(current);
    }
    free(stack);
}
```