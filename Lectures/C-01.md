---
marp: true
html: true
paginate: true
---

# A Crash Introduction to C

---
## Introduction to C

- Developed in 1972 by Dennis Ritchie.
- Influential in the development of many other languages, including Java.
- Known for its efficiency and control over system resources.

---
## Hello World in C

```c
#include <stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0;
}
```

---

### Slide 4: Compiling and Running C Programs
To compile a C program:
```bash
gcc program.c -o program
```

Run it
```bash
./program
Hello, world!
```

---
## Basic Syntax and Types in C

- Similar to Java in syntax. (Actually the other way around)
- No objects and methods
- Just primitive types, arrays, structs and functions 
```c
struct point {
    double x;
    double y;
}

void main() {
    int number = 10; // Integer type
    int[] a = {1, 3, 5, 6};
    struct point p = { 10.0, 20.0 }
}
```

---

## Defining Functions in C

```c
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

int main() {
    printf("Sum: %d\n", add(5, 3));
    return 0;
}
```
---

## Definition order & prototypes
```c
#include <stdio.h>

int add(int a, int b);

int main() {
    printf("Sum: %d\n", add(5, 3));
    return 0;
}

int add(int a, int b) {
    return a + b;
}
```

---

## Arrays in C

```c
 int numbers[] = {1, 2, 3, 4, 5};
 printf("First element: %d\n", numbers[0]);
 for (int i = 0; i < 5; i++)
    numbers[i] += 10;
 printf("First element: %d\n", numbers[0]);
```
Output
```bash
First element: 1
First element: 11
```

---
## Strings are array of chars (ASCII chars)
```c
char text[] = "Hello";
printf("text= %s\n", text);
printf("Length= %lu, number of bytes= %lu\n",
       strlen(text), sizeof text);
printf("First element= as int = %d, as char = '%c'\n",
       text[0], text[0]);
for (int i = 0; i < 5; i++)
    text[i] += 2;
printf("text= %s\n", text);
```
Output
```bash
text= Hello
Length= 5, number of bytes= 6
First element= as int = 72, as char = 'H'
text= Jgnnq

```
---
## Introduction to Pointers

- A pointer stores a memory address.
- Crucial for dynamic memory management.
- Pointers can be dereferenced to access the value they point to.
- `*` is used for dereferencing, `&` is used to get the address

---

## Example

```c
int a = 10;
int* p;
p = &a;
printf("%d %d %d\n", a, p, *p); 
```
Output
```bash
10 1793618604 10
```
---

## A more complex example
```c
int a, b, *p, **q;
a = 10;	b = 15;
p = &a;
printf("a = %d b = %d\n", a, b);

*p = 11;  
q = &p;
p = &b;
**q = 20;
printf("a = %d b = %d\n", a, b);

*q = p + 1;
**q = 40;
printf("a = %d b = %d\n", a, b);
```
Output
```bash
a = 10 b = 15
a = 11 b = 20
a = 40 b = 20
```
---

## Arrays, pointers and pointer arithmetic

Arrays in C are essentially a pointer to the first element of the array.
When you increment a pointer it increments it by the size of the pointer type

```c
int a[5] = {10, 20, 30, 40};

int* ptr = a; // Pointer to the first element of a
* (ptr + 1) = 22;
printf("a = {%d, %d, %d, %d}\n", a[0], a[1], a[2], a[3]);

ptr += 2;     // Now points to the third element of a
*ptr += 14;
printf("a = {%d, %d, %d, %d}\n", a[0], a[1], a[2], a[3]);
```
Output
```bash
a = {10, 22, 30, 40}
a = {10, 22, 44, 40}
```
---
## Structures in C

Like the fields of a `class` in Java.

Define a structure

```c
struct Person {
    char name[50];
    int age;
    float height;
};
```
Define a variable with the type of the structure and fill it
```c
struct Person john;
strcpy(john.name, "John Doe");  // Copying a string into the name field
john.age = 30;                  // Setting the age
john.height = 170;              // Setting the height
```
---
## Where is the memory allocated?

```c

// static: lives for the whole duration of the program execution
struct Person person1 = { "Jack", 18, 180 }; // static

void f() {
    // stack: lives while `f` is alive
    struct Person person2 = { "John", 21, 170 };
    printf("%s\n", person1.name);
    printf("%s\n", person2.name);
}
```

---

## Memory Allocation in C
- C allows you to handle memory allocation manually
- `malloc` is used to allocate memory
- `free` are used to free it.
- The memory is allocated in the 'heap'
- You are responsible of returning the memory to the heap (Using `free`)

---
## Example:

```c
// Create an array of `n` elements
// fill them with the given value
int* createArray(int n, int value) {
    // Allocates space for n integers
    int* array = (int*) malloc(n * sizeof(int));
    for (int i = 0; i< n; i++) 
        array[i] = value;
    return array;     
}
// Use it
int main() {
	int* a = createArray(3, 100);
	for (int i = 0; i < 3; i++) printf("a[%d] = %d\n", i, a[i]);
	free(a);
}
```
Output
```bash
a[0] = 100
a[1] = 100
a[2] = 100
```
---

## Problems with Memory Handling in C

- Memory leaks occur if `free` is not called after `malloc`.
- If you try to free an already freed block of memory you can get a crash
- Dangling pointers
  - It is a pointer to an already freed block of memory.
  - Using it can cause errors difficult to detect
  - Like modifying the memory of a different object
---

## Implementing a Stack in C

The node:
```c
struct Node {
    int value;
    struct Node* next;
};
```
Then I need a pointer to the first Node, (or to NULL if the stack is empty).

The functions that manipulate the stack (`pop`, `push`, etc) need to modify that pointer,
to be able to do that I will need to pass a pointer to the pointer of the first node.
To simplify the interface, I define a `typedef` alias:

```c
typedef struct Node** Stack;
```

---

## Using the stack
```c
Stack s = create_stack();   // Create the stack

push(s, 10);                // Push 2 values
push(s, 20);

printf("%d\n", pop(s));    // Pop the Values
printf("%d\n", pop(s));

delete_stack(s);           // Delete the stack
```
Output
```bash
20
10
```
---

## Push

- Allocate memory for a new node
- Fill the node with:
  - The value
  - The previous top of the `Stack`
  - Modify the top of the `Stack`

```c
void push(Stack stack, int value) {
    struct Node* node = (struct Node *) malloc(sizeof(struct Node));
    node->value = value;
    node->next = *stack;
    *stack = node;
}
```

---

## Pop

- Get current top and value
- Modify the top of the `Stack` (point it to the next `Node`)
- Free the memory of the previous top `Node`

```c
vint pop(Stack stack) {
    struct Node* node = *stack;
    int value = node->value;
    *stack = node->next;
    free(node);
    return value;
}

```

---

### Create a new `Stack`

- Allocate memory to hold the pointer to the top `Node`
- Fill it with `NULL`
- return it

```c
Stack create_stack() {
    Stack s = (struct Node**) malloc(sizeof(struct Node*));
    *s = NULL;
    return s;
}
```

---

### Delete the `Stack` (free associated memory)

- Get the pointer to the first `Node`
- While the pointer is not `NULL`
- Advance the pointer and free each `Node`
- Finally free the pointer to the first `Node`

```c
void delete_stack(Stack stack) {
    struct Node* node = *stack;
    while (node != NULL) {
        struct Node* current = node;
        node = node->next;
        free(current);
    }
    free(stack);
}
```