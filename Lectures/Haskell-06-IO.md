## INPUT OUTPUT---### Hello World```haskellmain = putStrLn "Hello, World!"``` Compile and run```bash❯ ghc hello.hs[1 of 2] Compiling Main             ( hello.hs, hello.o )[2 of 2] Linking hello❯ ./helloHello, World!```---### IO Operations and Types* ALL IO operations has some type IO a* Where IO is a data type: data IO a* For Example:```haskellgetLine::IO StringputStrLn:String -> IO ()```* Remember () is the tuple with no elements: Unit* main can be any IO a---###  ANOTHER EXAMPLEPrinting a value of any type that can be converted to a String```haskellprint::(Show a) => a -> IO ()print x = putStrLn (show x)main:: IO ()main = print [1, 2, 3]```---### Chaining IO Actions. The `do` notation```haskellmain = do            putStrLn "Welcome!"            putStrLn "Bienvenido!"            putStrLn "Bienvenue!"            putStrLn "Benvenuto!"```---### Using the value returned from an `IO` OperationFor example I want to read a line from the input (getLine) and then print it```haskellmain = putStrLn ("Hello " ++ getLine)``````1:30: error: [GHC-83865]    * Couldn't match expected type: String                  with actual type: IO String    * In the second argument of ‘(++)’, namely ‘getLine’      In the first argument of ‘putStrLn’, namely ‘("Hello " ++ getLine)’      In the expression: putStrLn ("Hello " ++ getLine)```---### Using the value returned from an `IO` Operation```haskellmain = do         name <- getLine         putStrLn ("Hello " ++ name)```---### Exercise: Greeting the UserWrite a program that asks the user for their name and age,and then prints a personalized message like:```Hi Ana, you are 25 years old!```---### Writing a function that returns an IO aFor example I want to write a function that reads a line and returns it reversed```haskellreadReversed = do                 name <- getLine                 reverse name```                 It doesn't work, because `reverse` returns a String and haskell is expecting an IO of some type.---### We need to wrap the result of reverse into an IOYou can use the `return` function:```haskellreturn::x -> IO x. -- It takes any value and wraps it into an IOreadReversed::IO StringreadReversed = do                 name <- getLine                 return (reverse name)```---### Looping using `if`Example, create a function that prints n times a value:```haskellWe can do:printN :: (Show a) => Int -> a -> IO ()printN n x = do if n <= 0 then return ()                else do                    print x                    printN (n-1) x```---### Actually there is a function `unless` defined like:```haskellimport Control.Monadunless::Bool -> IO () -> IO ()unless b e = do    if b then return () else e    printN n x = unless (n <= 0) $ do                print x                printN (n-1) x``` ---### Another example. Number the lines of the input```haskell-- Read the input until eof and print the lines numberedimport System.IO( isEOF )main = num 0num:: Int -> IO ()num n = do           eof <- isEOF           unless eof $ do                line <- getLine                putStrLn $ show n ++ ": " ++ line                num (n + 1)```---### Another example. Read from a disk file```haskellnumFile::String -> IO ()numFile fileName = do   content <- readFile fileName   printLines 1 (lines content)printLines::Int -> [String] -> IO ()printLines _ [] = return ()printLines n (x:xs) = do                         putStrLn $ show n ++ ": "++ x                         printLines (n+1) xs```---### Using command line arguments```haskellimport System.Environmentmain = do   args <- getArgs   if length args == 0 then do       putStrLn "Please specify the filename"       return ()   else        numFile (head args)```---### Exercise#### Read all files listed as arguments and print the number of words per fileFor example:```bash> wordcount file1.txt file2.txt file3.txtfile1.txt: 10file2.txt: 20file3.txt: 150```